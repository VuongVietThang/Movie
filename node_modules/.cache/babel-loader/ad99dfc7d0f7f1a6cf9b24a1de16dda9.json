{"ast":null,"code":"/**\n * Generates input IDs or names based on the provided attributes, range, and position.\n *\n * @param attribute - A single string or a tuple of two strings representing the attribute names.\n * @param range - A boolean indicating whether the input is part of a range.\n * @param position - Optional. Specifies the position ('start' or 'end') when `range` is true.\n * @returns A string representing the input ID or name.\n */\nvar getInputIdOrName = function (attribute, range, position) {\n  if (range && !Array.isArray(attribute)) {\n    return \"\".concat(attribute, \"-\").concat(position, \"-date\");\n  }\n\n  if (Array.isArray(attribute)) {\n    return position === 'start' ? attribute[0] : attribute[1];\n  }\n\n  return attribute;\n};\n/**\n * Parses a date string into a Date object based on the provided locale and time inclusion.\n *\n * @param dateString - The date string to parse.\n * @param locale - The locale to use for parsing the date string.\n * @param includeTime - Optional. Determines whether to include time in the parsed Date object.\n * @returns A Date object representing the parsed date and time, or `undefined` if parsing fails.\n */\n\n\nvar getLocalDateFromString = function (string, locale, time) {\n  if (!Number.isNaN(Date.parse(string))) {\n    return new Date(Date.parse(string));\n  }\n\n  var date = new Date(2013, 11, 31, 17, 19, 22);\n  var regex = time ? date.toLocaleString(locale) : date.toLocaleDateString(locale);\n  regex = regex.replace('2013', '(?<year>[0-9]{2,4})').replace('12', '(?<month>[0-9]{1,2})').replace('31', '(?<day>[0-9]{1,2})');\n\n  if (time) {\n    regex = regex.replace('5', '(?<hour>[0-9]{1,2})').replace('17', '(?<hour>[0-9]{1,2})').replace('19', '(?<minute>[0-9]{1,2})').replace('22', '(?<second>[0-9]{1,2})').replace('PM', '(?<ampm>[A-Z]{2})');\n  }\n\n  var rgx = new RegExp(\"\".concat(regex));\n  var partials = string.match(rgx);\n  if (partials === null) return;\n  var newDate = partials.groups && (time ? new Date(Number(partials.groups['year']), Number(partials.groups['month']) - 1, Number(partials.groups['day']), partials.groups['ampm'] ? partials.groups['ampm'] === 'PM' ? Number(partials.groups['hour']) + 12 : Number(partials.groups['hour']) : Number(partials.groups['hour']), Number(partials.groups['minute']), Number(partials.groups['second'])) : new Date(Number(partials.groups['year']), Number(partials.groups['month']) - 1, Number(partials.groups['day'])));\n  return newDate;\n};\n\nexport { getInputIdOrName, getLocalDateFromString };","map":{"version":3,"mappings":"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","names":["getInputIdOrName","attribute","range","position","Array","isArray","concat","getLocalDateFromString","string","locale","time","Number","isNaN","Date","parse","date","regex","toLocaleString","toLocaleDateString","replace","rgx","RegExp","partials","match","newDate","groups"],"sources":["C:\\wamp64\\www\\Movie-react\\node_modules\\@coreui\\react-pro\\src\\components\\date-range-picker\\utils.ts"],"sourcesContent":["/**\n * Generates input IDs or names based on the provided attributes, range, and position.\n *\n * @param attribute - A single string or a tuple of two strings representing the attribute names.\n * @param range - A boolean indicating whether the input is part of a range.\n * @param position - Optional. Specifies the position ('start' or 'end') when `range` is true.\n * @returns A string representing the input ID or name.\n */\nexport const getInputIdOrName = (\n  attribute: string | [string, string],\n  range: boolean,\n  position?: 'start' | 'end',\n): string => {\n  if (range && !Array.isArray(attribute)) {\n    return `${attribute}-${position}-date`\n  }\n\n  if (Array.isArray(attribute)) {\n    return position === 'start' ? attribute[0] : attribute[1]\n  }\n\n  return attribute\n}\n\n/**\n * Parses a date string into a Date object based on the provided locale and time inclusion.\n *\n * @param dateString - The date string to parse.\n * @param locale - The locale to use for parsing the date string.\n * @param includeTime - Optional. Determines whether to include time in the parsed Date object.\n * @returns A Date object representing the parsed date and time, or `undefined` if parsing fails.\n */\nexport const getLocalDateFromString = (\n  string: string,\n  locale: string,\n  time?: boolean,\n): Date | undefined => {\n  if (!Number.isNaN(Date.parse(string))) {\n    return new Date(Date.parse(string))\n  }\n\n  const date = new Date(2013, 11, 31, 17, 19, 22)\n  let regex = time ? date.toLocaleString(locale) : date.toLocaleDateString(locale)\n  regex = regex\n    .replace('2013', '(?<year>[0-9]{2,4})')\n    .replace('12', '(?<month>[0-9]{1,2})')\n    .replace('31', '(?<day>[0-9]{1,2})')\n\n  if (time) {\n    regex = regex\n      .replace('5', '(?<hour>[0-9]{1,2})')\n      .replace('17', '(?<hour>[0-9]{1,2})')\n      .replace('19', '(?<minute>[0-9]{1,2})')\n      .replace('22', '(?<second>[0-9]{1,2})')\n      .replace('PM', '(?<ampm>[A-Z]{2})')\n  }\n\n  const rgx = new RegExp(`${regex}`)\n  const partials = string.match(rgx)\n\n  if (partials === null) return\n\n  const newDate =\n    partials.groups &&\n    (time\n      ? new Date(\n          Number(partials.groups['year']),\n          Number(partials.groups['month']) - 1,\n          Number(partials.groups['day']),\n          partials.groups['ampm']\n            ? partials.groups['ampm'] === 'PM'\n              ? Number(partials.groups['hour']) + 12\n              : Number(partials.groups['hour'])\n            : Number(partials.groups['hour']),\n          Number(partials.groups['minute']),\n          Number(partials.groups['second']),\n        )\n      : new Date(\n          Number(partials.groups['year']),\n          Number(partials.groups['month']) - 1,\n          Number(partials.groups['day']),\n        ))\n\n  return newDate\n}\n"]},"metadata":{},"sourceType":"module"}