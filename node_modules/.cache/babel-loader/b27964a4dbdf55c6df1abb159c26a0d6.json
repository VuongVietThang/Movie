{"ast":null,"code":"import { __spreadArray } from '../../node_modules/tslib/tslib.es6.js';\n\nvar calculateClickValue = function (event, container, min, max, step, vertical, rtl) {\n  var clickPosition = getClickPosition(event, container, vertical, rtl);\n  var value = min + clickPosition * (max - min);\n  return roundToStep(value, step);\n};\n\nvar calculateMoveValue = function (event, container, min, max, step, vertical, rtl) {\n  var rect = container.getBoundingClientRect();\n  var position = vertical ? calculateVerticalPosition(event.clientY, rect) : calculateHorizontalPosition(event.clientX, rect, rtl);\n\n  if (typeof position === 'string') {\n    return position === 'max' ? max : min;\n  }\n\n  var value = min + position * (max - min);\n  return roundToStep(value, step);\n};\n\nvar calculateVerticalPosition = function (mouseY, rect) {\n  if (mouseY < rect.top) {\n    return 'max';\n  }\n\n  if (mouseY > rect.bottom) {\n    return 'min';\n  }\n\n  return Math.min(Math.max((rect.bottom - mouseY) / rect.height, 0), 1);\n};\n\nvar calculateHorizontalPosition = function (mouseX, rect, rtl) {\n  if (mouseX < rect.left) {\n    return rtl ? 'max' : 'min';\n  }\n\n  if (mouseX > rect.right) {\n    return rtl ? 'min' : 'max';\n  }\n\n  var relativeX = rtl ? rect.right - mouseX : mouseX - rect.left;\n  return Math.min(Math.max(relativeX / rect.width, 0), 1);\n};\n\nvar calculateLabelPosition = function (min, max, labels, label, index) {\n  if (typeof label === 'object' && 'value' in label) {\n    return \"\".concat((label.value - min) / (max - min) * 100, \"%\");\n  }\n\n  return \"\".concat(index / (labels.length - 1) * 100, \"%\");\n};\n\nvar calculateTooltipPosition = function (min, max, value, thumbSize, vertical, rtl) {\n  var percent = (value - min) / (max - min);\n  var margin = percent > 0.5 ? \"-\".concat((percent - 0.5) * thumbSize.value).concat(thumbSize.unit) : \"\".concat((0.5 - percent) * thumbSize.value).concat(thumbSize.unit);\n\n  if (vertical) {\n    return {\n      bottom: \"\".concat(percent * 100, \"%\"),\n      marginBottom: margin\n    };\n  }\n\n  return rtl ? {\n    right: \"\".concat(percent * 100, \"%\"),\n    marginRight: margin\n  } : {\n    left: \"\".concat(percent * 100, \"%\"),\n    marginLeft: margin\n  };\n};\n\nvar getClickPosition = function (event, container, vertical, rtl) {\n  // MouseEvent doesn't have `offsetX`/`offsetY`, so we need to use `event.nativeEvent` instead\n  var _a = event.nativeEvent,\n      offsetX = _a.offsetX,\n      offsetY = _a.offsetY;\n  var offsetWidth = container.offsetWidth,\n      offsetHeight = container.offsetHeight;\n\n  if (vertical) {\n    return 1 - offsetY / offsetHeight;\n  }\n\n  return rtl ? 1 - offsetX / offsetWidth : offsetX / offsetWidth;\n};\n\nvar getLabelValue = function (min, max, labels, label, index) {\n  return typeof label === 'object' && 'value' in label ? label.value : min + index / (labels.length - 1) * (max - min);\n};\n\nvar getNearestValueIndex = function (value, values) {\n  var valuesLength = values.length;\n\n  if (value < values[0]) {\n    return 0;\n  }\n\n  if (value > values[valuesLength - 1]) {\n    return valuesLength - 1;\n  }\n\n  var distances = values.map(function (v) {\n    return Math.abs(v - value);\n  });\n  var min = Math.min.apply(Math, distances);\n  var firstIndex = distances.indexOf(min);\n  return value < values[firstIndex] ? firstIndex : distances.lastIndexOf(min);\n};\n\nvar getThumbSize = function (element, vertical) {\n  var value = globalThis.getComputedStyle(element, null).getPropertyValue(vertical ? '--cui-range-slider-thumb-height' : '--cui-range-slider-thumb-width');\n  var regex = /^(\\d+\\.?\\d*)([%a-z]*)$/i;\n  var match = value.match(regex);\n\n  if (match) {\n    return {\n      value: Number.parseFloat(match[1]),\n      unit: match[2] || null\n    };\n  }\n\n  return null;\n};\n\nvar roundToStep = function (number, step) {\n  var _step = step === 0 ? 1 : step;\n\n  return Math.round(number / _step) * _step;\n};\n\nvar updateGradient = function (min, max, values, vertical, rtl) {\n  var minVal = Math.min.apply(Math, values);\n  var maxVal = Math.max.apply(Math, values);\n  var from = (minVal - min) / (max - min) * 100;\n  var to = (maxVal - min) / (max - min) * 100;\n  var direction = vertical ? 'to top' : rtl ? 'to left' : 'to right';\n  return {\n    backgroundImage: values.length === 1 ? \"linear-gradient(\\n    \".concat(direction, \",\\n    var(--cui-range-slider-track-in-range-bg) 0%,\\n    var(--cui-range-slider-track-in-range-bg) \").concat(to, \"%,\\n    transparent \").concat(to, \"%,\\n    transparent 100%\\n  )\") : \"linear-gradient(\\n    \".concat(direction, \",\\n    transparent 0%,\\n    transparent \").concat(from, \"%,\\n    var(--cui-range-slider-track-in-range-bg) \").concat(from, \"%,\\n    var(--cui-range-slider-track-in-range-bg) \").concat(to, \"%,\\n    transparent \").concat(to, \"%,\\n    transparent 100%\\n  )\")\n  };\n};\n\nvar updateValue = function (value, values, distance, index) {\n  var newValue = __spreadArray([], values, true);\n\n  newValue[index] = validateValue(value, values, distance, index);\n  return newValue;\n};\n\nvar validateValue = function (value, values, distance, index) {\n  // If there's only one value, return it as is\n  if (values.length === 1) {\n    return value;\n  } // Determine previous and next values if they exist\n\n\n  var prevValue = index > 0 ? values[index - 1] : undefined;\n  var nextValue = index < values.length - 1 ? values[index + 1] : undefined; // If it's the first element, ensure it's not too close to the next value\n\n  if (index === 0 && nextValue !== undefined) {\n    return Math.min(value, nextValue - distance);\n  } // If it's the last element, ensure it's not too close to the previous value\n\n\n  if (index === values.length - 1 && prevValue !== undefined) {\n    return Math.max(value, prevValue + distance);\n  } // For middle elements, ensure the value is within the allowed distance from both neighbors\n\n\n  if (prevValue !== undefined && nextValue !== undefined) {\n    var minVal = prevValue + distance;\n    var maxVal = nextValue - distance;\n    return Math.min(Math.max(value, minVal), maxVal);\n  } // Fallback: If for some reason prevValue or nextValue is undefined, return the original value\n\n\n  return value;\n};\n\nexport { calculateClickValue, calculateHorizontalPosition, calculateLabelPosition, calculateMoveValue, calculateTooltipPosition, calculateVerticalPosition, getClickPosition, getLabelValue, getNearestValueIndex, getThumbSize, roundToStep, updateGradient, updateValue, validateValue };","map":{"version":3,"mappings":";;AAGa,uBAAmB,GAAG,UACjCA,KADiC,EAEjCC,SAFiC,EAGjCC,GAHiC,EAIjCC,GAJiC,EAKjCC,IALiC,EAMjCC,QANiC,EAOjCC,GAPiC,EAOrB;AAEZ,MAAMC,aAAa,GAAGC,gBAAgB,CAACR,KAAD,EAAQC,SAAR,EAAmBI,QAAnB,EAA6BC,GAA7B,CAAtC;AACA,MAAMG,KAAK,GAAGP,GAAG,GAAGK,aAAa,IAAIJ,GAAG,GAAGD,GAAV,CAAjC;AACA,SAAOQ,WAAW,CAACD,KAAD,EAAQL,IAAR,CAAlB;AACF,CAZa;;AAcA,sBAAkB,GAAG,UAChCJ,KADgC,EAEhCC,SAFgC,EAGhCC,GAHgC,EAIhCC,GAJgC,EAKhCC,IALgC,EAMhCC,QANgC,EAOhCC,GAPgC,EAOpB;AAEZ,MAAMK,IAAI,GAAGV,SAAS,CAACW,qBAAV,EAAb;AACA,MAAMC,QAAQ,GAAGR,WACbS,yBAAyB,CAACd,KAAK,CAACe,OAAP,EAAgBJ,IAAhB,CADZ,GAEbK,2BAA2B,CAAChB,KAAK,CAACiB,OAAP,EAAgBN,IAAhB,EAAsBL,GAAtB,CAF/B;;AAIA,MAAI,OAAOO,QAAP,KAAoB,QAAxB,EAAkC;AAChC,WAAOA,QAAQ,KAAK,KAAb,GAAqBV,GAArB,GAA2BD,GAAlC;;;AAGF,MAAMO,KAAK,GAAGP,GAAG,GAAGW,QAAQ,IAAIV,GAAG,GAAGD,GAAV,CAA5B;AAEA,SAAOQ,WAAW,CAACD,KAAD,EAAQL,IAAR,CAAlB;AACF,CArBa;;AAuBA,6BAAyB,GAAG,UAACc,MAAD,EAAiBP,IAAjB,EAA8B;AACrE,MAAIO,MAAM,GAAGP,IAAI,CAACQ,GAAlB,EAAuB;AACrB,WAAO,KAAP;;;AAGF,MAAID,MAAM,GAAGP,IAAI,CAACS,MAAlB,EAA0B;AACxB,WAAO,KAAP;;;AAGF,SAAOC,IAAI,CAACnB,GAAL,CAASmB,IAAI,CAAClB,GAAL,CAAS,CAACQ,IAAI,CAACS,MAAL,GAAcF,MAAf,IAAyBP,IAAI,CAACW,MAAvC,EAA+C,CAA/C,CAAT,EAA4D,CAA5D,CAAP;AACF,CAVa;;IAYAN,2BAA2B,GAAG,UAACO,MAAD,EAAiBZ,IAAjB,EAAgCL,GAAhC,EAA4C;AACrF,MAAIiB,MAAM,GAAGZ,IAAI,CAACa,IAAlB,EAAwB;AACtB,WAAOlB,GAAG,GAAG,KAAH,GAAW,KAArB;;;AAGF,MAAIiB,MAAM,GAAGZ,IAAI,CAACc,KAAlB,EAAyB;AACvB,WAAOnB,GAAG,GAAG,KAAH,GAAW,KAArB;;;AAGF,MAAMoB,SAAS,GAAGpB,GAAG,GAAGK,IAAI,CAACc,KAAL,GAAaF,MAAhB,GAAyBA,MAAM,GAAGZ,IAAI,CAACa,IAA5D;AACA,SAAOH,IAAI,CAACnB,GAAL,CAASmB,IAAI,CAAClB,GAAL,CAASuB,SAAS,GAAGf,IAAI,CAACgB,KAA1B,EAAiC,CAAjC,CAAT,EAA8C,CAA9C,CAAP;AACF;;AAEO,IAAMC,sBAAsB,GAAG,UACpC1B,GADoC,EAEpCC,GAFoC,EAGpC0B,MAHoC,EAIpCC,KAJoC,EAKpCC,KALoC,EAKvB;AAEb,MAAI,OAAOD,KAAP,KAAiB,QAAjB,IAA6B,WAAWA,KAA5C,EAAmD;AACjD,WAAO,UAAI,CAACA,KAAK,CAACrB,KAAN,GAAcP,GAAf,KAAuBC,GAAG,GAAGD,GAA7B,CAAD,GAAsC,GAAzC,EAA4C,GAA5C,CAAP;;;AAGF,SAAO,GAAG8B,MAAH,CAAID,KAAK,IAAIF,MAAM,CAACI,MAAP,GAAgB,CAApB,CAAN,GAAgC,GAAnC,EAAsC,GAAtC,CAAP;AACF,CAZO;;AAcA,IAAMC,wBAAwB,GAAG,UACtChC,GADsC,EAEtCC,GAFsC,EAGtCM,KAHsC,EAItC0B,SAJsC,EAKtC9B,QALsC,EAMtCC,GANsC,EAM1B;AAEZ,MAAM8B,OAAO,GAAG,CAAC3B,KAAK,GAAGP,GAAT,KAAiBC,GAAG,GAAGD,GAAvB,CAAhB;AACA,MAAMmC,MAAM,GACVD,OAAO,GAAG,GAAV,GACI,WAAI,CAACA,OAAO,GAAG,GAAX,IAAkBD,SAAS,CAAC1B,KAAhC,EAAqCuB,MAArC,CAAwCG,SAAS,CAACG,IAAlD,CADJ,GAEI,GAAGN,MAAH,CAAG,CAAC,MAAMI,OAAP,IAAkBD,SAAS,CAAC1B,KAA/B,EAAuCuB,MAAvC,CAAuCG,SAAS,CAACG,IAAjD,CAHN;;AAKA,MAAIjC,QAAJ,EAAc;AACZ,WAAO;AACLe,YAAM,EAAE,UAAGgB,OAAO,GAAG,GAAb,EAAmB,GAAnB,CADH;AAELG,kBAAY,EAAEF;AAFT,KAAP;;;AAMF,SAAO/B,MACH;AAAEmB,SAAK,EAAE,GAAGO,MAAH,CAAGI,OAAO,GAAG,GAAb,EAAmB,GAAnB,CAAT;AAA8BI,eAAW,EAAEH;AAA3C,GADG,GAEH;AAAEb,QAAI,EAAE,UAAGY,OAAO,GAAG,GAAb,EAAgB,GAAhB,CAAR;AAA6BK,cAAU,EAAEJ;AAAzC,GAFJ;AAGF,CAxBO;;AA0BM,oBAAgB,GAAG,UAC9BrC,KAD8B,EAE9BC,SAF8B,EAG9BI,QAH8B,EAI9BC,GAJ8B,EAIlB;;AAGN,WAAuBN,KAAK,CAAC0C,WAA7B;AAAA,MAAEC,OAAO,aAAT;AAAA,MAAWC,OAAO,aAAlB;AACE,iBAAW,GAAmB3C,SAAS,YAAvC;AAAA,MAAa4C,YAAY,GAAK5C,SAAS,aAAvC;;AAER,MAAII,QAAJ,EAAc;AACZ,WAAO,IAAIuC,OAAO,GAAGC,YAArB;;;AAGF,SAAOvC,GAAG,GAAG,IAAIqC,OAAO,GAAGG,WAAjB,GAA+BH,OAAO,GAAGG,WAAnD;AACF,CAfa;;AAiBN,IAAMC,aAAa,GAAG,UAC3B7C,GAD2B,EAE3BC,GAF2B,EAG3B0B,MAH2B,EAI3BC,KAJ2B,EAK3BC,KAL2B,EAKd;AAEb,gBAAOD,KAAP,KAAiB,QAAjB,IAA6B,WAAWA,KAAxC,GACIA,KAAK,CAACrB,KADV,GAEIP,GAAG,GAAI6B,KAAK,IAAIF,MAAM,CAACI,MAAP,GAAgB,CAApB,CAAN,IAAiC9B,GAAG,GAAGD,GAAvC,CAFV;AAAA,CAPK;;AAWM,wBAAoB,GAAG,UAACO,KAAD,EAAgBuC,MAAhB,EAAgC;AAClE,MAAMC,YAAY,GAAGD,MAAM,CAACf,MAA5B;;AAEA,MAAIxB,KAAK,GAAGuC,MAAM,CAAC,CAAD,CAAlB,EAAuB;AACrB,WAAO,CAAP;;;AAGF,MAAIvC,KAAK,GAAGuC,MAAM,CAACC,YAAY,GAAG,CAAhB,CAAlB,EAAsC;AACpC,WAAOA,YAAY,GAAG,CAAtB;;;AAGF,MAAMC,SAAS,GAAGF,MAAM,CAACG,GAAP,CAAW,UAACC,CAAD,EAAO;AAAA,eAAI,CAACC,GAAL,CAASD,CAAC,GAAG3C,KAAb;AAAmB,GAArC,CAAlB;AACA,MAAMP,GAAG,GAAGmB,IAAI,CAACnB,GAAL,CAAQoD,KAAR,OAAYJ,SAAZ,CAAZ;AACA,MAAMK,UAAU,GAAGL,SAAS,CAACM,OAAV,CAAkBtD,GAAlB,CAAnB;AAEA,SAAOO,KAAK,GAAGuC,MAAM,CAACO,UAAD,CAAd,GAA6BA,UAA7B,GAA0CL,SAAS,CAACO,WAAV,CAAsBvD,GAAtB,CAAjD;AACF,CAhBa;;AAkBA,gBAAY,GAAG,UAACwD,OAAD,EAA0BrD,QAA1B,EAA2C;AACrE,MAAMI,KAAK,GAAGkD,WACXC,gBADW,CACMF,OADN,EACe,IADf,EAEXG,gBAFW,CAGVxD,QAAQ,GAAG,iCAAH,GAAuC,gCAHrC,CAAd;AAMA,MAAMyD,KAAK,GAAG,yBAAd;AACA,MAAMC,KAAK,GAAGtD,KAAK,CAACsD,KAAN,CAAYD,KAAZ,CAAd;;AAEA,MAAIC,KAAJ,EAAW;AACT,WAAO;AACLtD,WAAK,EAAEuD,MAAM,CAACC,UAAP,CAAkBF,KAAK,CAAC,CAAD,CAAvB,CADF;AAELzB,UAAI,EAAEyB,KAAK,CAAC,CAAD,CAAL,IAAY;AAFb,KAAP;;;AAMF,SAAO,IAAP;AACF,CAlBa;;AAoBA,eAAW,GAAG,UAACG,MAAD,EAAiB9D,IAAjB,EAA6B;AACtD,MAAM+D,KAAK,GAAG/D,IAAI,KAAK,CAAT,GAAa,CAAb,GAAiBA,IAA/B;;AACA,SAAOiB,IAAI,CAAC+C,KAAL,CAAWF,MAAM,GAAGC,KAApB,IAA6BA,KAApC;AACF,CAHa;;AAKN,IAAME,cAAc,GAAG,UAC5BnE,GAD4B,EAE5BC,GAF4B,EAG5B6C,MAH4B,EAI5B3C,QAJ4B,EAK5BC,GAL4B,EAKhB;AAEZ,MAAMgE,MAAM,GAAGjD,IAAI,CAACnB,GAAL,CAAQoD,KAAR,OAAYN,MAAZ,CAAf;AACA,MAAMuB,MAAM,GAAGlD,IAAI,CAAClB,GAAL,CAAQmD,KAAR,OAAYN,MAAZ,CAAf;AAEA,MAAMwB,IAAI,GAAI,CAACF,MAAM,GAAGpE,GAAV,KAAkBC,GAAG,GAAGD,GAAxB,CAAD,GAAiC,GAA9C;AACA,MAAMuE,EAAE,GAAI,CAACF,MAAM,GAAGrE,GAAV,KAAkBC,GAAG,GAAGD,GAAxB,CAAD,GAAiC,GAA5C;AAEA,MAAMwE,SAAS,GAAGrE,QAAQ,GAAG,QAAH,GAAcC,GAAG,GAAG,SAAH,GAAe,UAA1D;AAEA,SAAO;AACLqE,mBAAe,EACb3B,MAAM,CAACf,MAAP,KAAkB,CAAlB,GACI,yBACJD,MADI,CACJ0C,SADI,EACK,sGADL,EACK1C,MADL,CAGsCyC,EAHtC,EAGwC,sBAHxC,EAGwCzC,MAHxC,CAIQyC,EAJR,EAMN,+BANM,CADJ,GAQI,yBACJzC,MADI,CACJ0C,SADI,EAGQ,0CAHR,EAGQ1C,MAHR,CAGQwC,IAHR,EAIsC,oDAJtC,EAIsCxC,MAJtC,CAIsCwC,IAJtC,EAKsC,oDALtC,EAKsCxC,MALtC,CAKsCyC,EALtC,EAMQ,sBANR,EAMQzC,MANR,CAMQyC,EANR,EAQN,+BARM;AAVD,GAAP;AAoBF,CAnCO;;AAqCM,eAAW,GAAG,UAAChE,KAAD,EAAgBuC,MAAhB,EAAkC4B,QAAlC,EAAoD7C,KAApD,EAAiE;AAC1F,MAAM8C,QAAQ,qBAAO7B,MAAP,EAAa,IAAb,CAAd;;AACA6B,UAAQ,CAAC9C,KAAD,CAAR,GAAkB+C,aAAa,CAACrE,KAAD,EAAQuC,MAAR,EAAgB4B,QAAhB,EAA0B7C,KAA1B,CAA/B;AACA,SAAO8C,QAAP;AACF,CAJa;;AAMA,iBAAa,GAAG,UAACpE,KAAD,EAAgBuC,MAAhB,EAAkC4B,QAAlC,EAAoD7C,KAApD,EAAiE;;AAE5F,MAAIiB,MAAM,CAACf,MAAP,KAAkB,CAAtB,EAAyB;AACvB,WAAOxB,KAAP;GAH0F;;;AAO5F,MAAMsE,SAAS,GAAuBhD,KAAK,GAAG,CAAR,GAAYiB,MAAM,CAACjB,KAAK,GAAG,CAAT,CAAlB,GAAgCiD,SAAtE;AACA,MAAMC,SAAS,GAAuBlD,KAAK,GAAGiB,MAAM,CAACf,MAAP,GAAgB,CAAxB,GAA4Be,MAAM,CAACjB,KAAK,GAAG,CAAT,CAAlC,GAAgDiD,SAAtF,CAR4F;;AAW5F,MAAIjD,KAAK,KAAK,CAAV,IAAekD,SAAS,KAAKD,SAAjC,EAA4C;AAC1C,WAAO3D,IAAI,CAACnB,GAAL,CAASO,KAAT,EAAgBwE,SAAS,GAAGL,QAA5B,CAAP;GAZ0F;;;AAgB5F,MAAI7C,KAAK,KAAKiB,MAAM,CAACf,MAAP,GAAgB,CAA1B,IAA+B8C,SAAS,KAAKC,SAAjD,EAA4D;AAC1D,WAAO3D,IAAI,CAAClB,GAAL,CAASM,KAAT,EAAgBsE,SAAS,GAAGH,QAA5B,CAAP;GAjB0F;;;AAqB5F,MAAIG,SAAS,KAAKC,SAAd,IAA2BC,SAAS,KAAKD,SAA7C,EAAwD;AACtD,QAAMV,MAAM,GAAGS,SAAS,GAAGH,QAA3B;AACA,QAAML,MAAM,GAAGU,SAAS,GAAGL,QAA3B;AACA,WAAOvD,IAAI,CAACnB,GAAL,CAASmB,IAAI,CAAClB,GAAL,CAASM,KAAT,EAAgB6D,MAAhB,CAAT,EAAkCC,MAAlC,CAAP;GAxB0F;;;AA4B5F,SAAO9D,KAAP;AACF,CA7Ba","names":["event","container","min","max","step","vertical","rtl","clickPosition","getClickPosition","value","roundToStep","rect","getBoundingClientRect","position","calculateVerticalPosition","clientY","calculateHorizontalPosition","clientX","mouseY","top","bottom","Math","height","mouseX","left","right","relativeX","width","calculateLabelPosition","labels","label","index","concat","length","calculateTooltipPosition","thumbSize","percent","margin","unit","marginBottom","marginRight","marginLeft","nativeEvent","offsetX","offsetY","offsetHeight","offsetWidth","getLabelValue","values","valuesLength","distances","map","v","abs","apply","firstIndex","indexOf","lastIndexOf","element","globalThis","getComputedStyle","getPropertyValue","regex","match","Number","parseFloat","number","_step","round","updateGradient","minVal","maxVal","from","to","direction","backgroundImage","distance","newValue","validateValue","prevValue","undefined","nextValue"],"sources":["C:\\wamp64\\www\\Movie-react\\node_modules\\@coreui\\react-pro\\src\\components\\range-slider\\utils.ts"],"sourcesContent":["import React from 'react'\nimport type { Label, ThumbSize } from './types'\n\nexport const calculateClickValue = (\n  event: React.MouseEvent,\n  container: HTMLDivElement,\n  min: number,\n  max: number,\n  step: number,\n  vertical: boolean,\n  rtl: boolean,\n) => {\n  const clickPosition = getClickPosition(event, container, vertical, rtl)\n  const value = min + clickPosition * (max - min)\n  return roundToStep(value, step)\n}\n\nexport const calculateMoveValue = (\n  event: MouseEvent,\n  container: HTMLDivElement,\n  min: number,\n  max: number,\n  step: number,\n  vertical: boolean,\n  rtl: boolean,\n) => {\n  const rect = container.getBoundingClientRect()\n  const position = vertical\n    ? calculateVerticalPosition(event.clientY, rect)\n    : calculateHorizontalPosition(event.clientX, rect, rtl)\n\n  if (typeof position === 'string') {\n    return position === 'max' ? max : min\n  }\n\n  const value = min + position * (max - min)\n\n  return roundToStep(value, step)\n}\n\nexport const calculateVerticalPosition = (mouseY: number, rect: DOMRect) => {\n  if (mouseY < rect.top) {\n    return 'max'\n  }\n\n  if (mouseY > rect.bottom) {\n    return 'min'\n  }\n\n  return Math.min(Math.max((rect.bottom - mouseY) / rect.height, 0), 1)\n}\n\nexport const calculateHorizontalPosition = (mouseX: number, rect: DOMRect, rtl: boolean) => {\n  if (mouseX < rect.left) {\n    return rtl ? 'max' : 'min'\n  }\n\n  if (mouseX > rect.right) {\n    return rtl ? 'min' : 'max'\n  }\n\n  const relativeX = rtl ? rect.right - mouseX : mouseX - rect.left\n  return Math.min(Math.max(relativeX / rect.width, 0), 1)\n}\n\nexport const calculateLabelPosition = (\n  min: number,\n  max: number,\n  labels: Label[],\n  label: Label,\n  index: number,\n) => {\n  if (typeof label === 'object' && 'value' in label) {\n    return `${((label.value - min) / (max - min)) * 100}%`\n  }\n\n  return `${(index / (labels.length - 1)) * 100}%`\n}\n\nexport const calculateTooltipPosition = (\n  min: number,\n  max: number,\n  value: number,\n  thumbSize: ThumbSize,\n  vertical: boolean,\n  rtl: boolean,\n) => {\n  const percent = (value - min) / (max - min)\n  const margin =\n    percent > 0.5\n      ? `-${(percent - 0.5) * thumbSize.value}${thumbSize.unit}`\n      : `${(0.5 - percent) * thumbSize.value}${thumbSize.unit}`\n\n  if (vertical) {\n    return {\n      bottom: `${percent * 100}%`,\n      marginBottom: margin,\n    }\n  }\n\n  return rtl\n    ? { right: `${percent * 100}%`, marginRight: margin }\n    : { left: `${percent * 100}%`, marginLeft: margin }\n}\n\nexport const getClickPosition = (\n  event: React.MouseEvent,\n  container: HTMLDivElement,\n  vertical: boolean,\n  rtl: boolean,\n) => {\n  // MouseEvent doesn't have `offsetX`/`offsetY`, so we need to use `event.nativeEvent` instead\n  const { offsetX, offsetY } = event.nativeEvent\n  const { offsetWidth, offsetHeight } = container\n\n  if (vertical) {\n    return 1 - offsetY / offsetHeight\n  }\n\n  return rtl ? 1 - offsetX / offsetWidth : offsetX / offsetWidth\n}\n\nexport const getLabelValue = (\n  min: number,\n  max: number,\n  labels: Label[],\n  label: Label,\n  index: number,\n) =>\n  typeof label === 'object' && 'value' in label\n    ? label.value\n    : min + (index / (labels.length - 1)) * (max - min)\n\nexport const getNearestValueIndex = (value: number, values: number[]) => {\n  const valuesLength = values.length\n\n  if (value < values[0]) {\n    return 0\n  }\n\n  if (value > values[valuesLength - 1]) {\n    return valuesLength - 1\n  }\n\n  const distances = values.map((v) => Math.abs(v - value))\n  const min = Math.min(...distances)\n  const firstIndex = distances.indexOf(min)\n\n  return value < values[firstIndex] ? firstIndex : distances.lastIndexOf(min)\n}\n\nexport const getThumbSize = (element: HTMLDivElement, vertical: boolean): ThumbSize | null => {\n  const value = globalThis\n    .getComputedStyle(element, null)\n    .getPropertyValue(\n      vertical ? '--cui-range-slider-thumb-height' : '--cui-range-slider-thumb-width',\n    )\n\n  const regex = /^(\\d+\\.?\\d*)([%a-z]*)$/i\n  const match = value.match(regex)\n\n  if (match) {\n    return {\n      value: Number.parseFloat(match[1]),\n      unit: match[2] || null,\n    }\n  }\n\n  return null\n}\n\nexport const roundToStep = (number: number, step: number) => {\n  const _step = step === 0 ? 1 : step\n  return Math.round(number / _step) * _step\n}\n\nexport const updateGradient = (\n  min: number,\n  max: number,\n  values: number[],\n  vertical: boolean,\n  rtl: boolean,\n) => {\n  const minVal = Math.min(...values)\n  const maxVal = Math.max(...values)\n\n  const from = ((minVal - min) / (max - min)) * 100\n  const to = ((maxVal - min) / (max - min)) * 100\n\n  const direction = vertical ? 'to top' : rtl ? 'to left' : 'to right'\n\n  return {\n    backgroundImage:\n      values.length === 1\n        ? `linear-gradient(\n    ${direction},\n    var(--cui-range-slider-track-in-range-bg) 0%,\n    var(--cui-range-slider-track-in-range-bg) ${to}%,\n    transparent ${to}%,\n    transparent 100%\n  )`\n        : `linear-gradient(\n    ${direction},\n    transparent 0%,\n    transparent ${from}%,\n    var(--cui-range-slider-track-in-range-bg) ${from}%,\n    var(--cui-range-slider-track-in-range-bg) ${to}%,\n    transparent ${to}%,\n    transparent 100%\n  )`,\n  }\n}\n\nexport const updateValue = (value: number, values: number[], distance: number, index: number) => {\n  const newValue = [...values]\n  newValue[index] = validateValue(value, values, distance, index)\n  return newValue\n}\n\nexport const validateValue = (value: number, values: number[], distance: number, index: number) => {\n  // If there's only one value, return it as is\n  if (values.length === 1) {\n    return value\n  }\n\n  // Determine previous and next values if they exist\n  const prevValue: number | undefined = index > 0 ? values[index - 1] : undefined\n  const nextValue: number | undefined = index < values.length - 1 ? values[index + 1] : undefined\n\n  // If it's the first element, ensure it's not too close to the next value\n  if (index === 0 && nextValue !== undefined) {\n    return Math.min(value, nextValue - distance)\n  }\n\n  // If it's the last element, ensure it's not too close to the previous value\n  if (index === values.length - 1 && prevValue !== undefined) {\n    return Math.max(value, prevValue + distance)\n  }\n\n  // For middle elements, ensure the value is within the allowed distance from both neighbors\n  if (prevValue !== undefined && nextValue !== undefined) {\n    const minVal = prevValue + distance\n    const maxVal = nextValue - distance\n    return Math.min(Math.max(value, minVal), maxVal)\n  }\n\n  // Fallback: If for some reason prevValue or nextValue is undefined, return the original value\n  return value\n}\n"]},"metadata":{},"sourceType":"module"}