{"ast":null,"code":"/**\n * Converts a 12-hour time format to a 24-hour time format.\n * @param {('am' | 'pm')} abbr The abbreviation indicating AM or PM.\n * @param {number} hour The hour to be converted.\n * @returns {number} The hour in 24-hour format.\n */\nvar convert12hTo24h = function (abbr, hour) {\n  if (abbr === 'am' && hour === 12) {\n    return 0;\n  }\n\n  if (abbr === 'am') {\n    return hour;\n  }\n\n  if (abbr === 'pm' && hour === 12) {\n    return 12;\n  }\n\n  return hour + 12;\n};\n/**\n * Converts a 24-hour time format to a 12-hour format.\n * @param {number} hour The hour to be converted.\n * @returns {number} The hour in 12-hour format.\n */\n\n\nvar convert24hTo12h = function (hour) {\n  return hour % 12 || 12;\n};\n/**\n * Converts a time input into a Date object.\n * @param {Date | string | null | undefined} time The time input to be converted.\n * @returns {Date | null} The converted Date object or null if the input is falsy.\n */\n\n\nvar convertTimeToDate = function (time) {\n  return time ? time instanceof Date ? time : new Date(\"1970-01-01 \".concat(time)) : null;\n};\n/**\n * Retrieves the AM/PM part of the specified date according to the given locale.\n * @param {Date} date The date from which to extract the AM/PM part.\n * @param {string} locale The locale to use for formatting.\n * @returns {string} 'am' or 'pm' based on the given date and locale.\n */\n\n\nvar getAmPm = function (date, locale) {\n  if (date.toLocaleTimeString(locale).includes('AM')) {\n    return 'am';\n  }\n\n  if (date.toLocaleTimeString(locale).includes('PM')) {\n    return 'pm';\n  }\n\n  return date.getHours() >= 12 ? 'pm' : 'am';\n};\n/**\n * Formats an array of time values (hours, minutes, or seconds) according to the specified locale and partial.\n * @param {number[]} values An array of time values to format.\n * @param {string} locale The locale to use for formatting.\n * @param {('hour' | 'minute' | 'second')} partial The type of time value to format.\n * @returns {Array} An array of objects with the original value and its localized label.\n */\n\n\nvar formatTimePartials = function (values, locale, partial) {\n  var date = new Date();\n  var forceTwoDigit = shouldUseTwoDigitHour(locale);\n  var formatter = new Intl.DateTimeFormat(locale, {\n    hour: forceTwoDigit ? '2-digit' : 'numeric',\n    minute: '2-digit',\n    second: '2-digit'\n  });\n  return values.map(function (value) {\n    var _a;\n\n    if (partial === 'hour') {\n      date.setHours(value);\n    }\n\n    if (partial === 'minute') {\n      date.setMinutes(value);\n    }\n\n    if (partial === 'second') {\n      date.setSeconds(value);\n    }\n\n    return {\n      value: value,\n      label: ((_a = formatter.formatToParts(date).find(function (part) {\n        return part.type === partial;\n      })) === null || _a === void 0 ? void 0 : _a.value) || ''\n    };\n  });\n};\n/**\n * Generates localized time partials (hours, minutes, seconds) based on the given parameters.\n * @param {string} locale The locale to use for generating localized time partials.\n * @param {'auto' | boolean} ampm Determines whether to use 12-hour or 24-hour format. 'auto' decides based on locale.\n * @param {boolean | number[] | Function} hours An array of hours, a boolean, or a function to generate hours.\n * @param {boolean | number[] | Function} minutes An array of minutes, a boolean, or a function to generate minutes.\n * @param {boolean | number[] | Function} seconds An array of seconds, a boolean, or a function to generate seconds.\n * @returns {LocalizedTimePartials} An object containing arrays of localized time partials and a boolean indicating if 12-hour format is used.\n */\n\n\nvar getLocalizedTimePartials = function (locale, ampm, hours, minutes, seconds) {\n  if (ampm === void 0) {\n    ampm = 'auto';\n  }\n\n  if (hours === void 0) {\n    hours = [];\n  }\n\n  if (minutes === void 0) {\n    minutes = [];\n  }\n\n  if (seconds === void 0) {\n    seconds = [];\n  }\n\n  var hour12 = ampm === 'auto' && isAmPm(locale) || ampm === true;\n  var listOfHours = Array.isArray(hours) && hours.length > 0 ? hours : typeof hours === 'function' ? Array.from({\n    length: hour12 ? 12 : 24\n  }, function (_, i) {\n    return hour12 ? i + 1 : i;\n  }).filter(function (hour) {\n    return hours(hour);\n  }) : Array.from({\n    length: hour12 ? 12 : 24\n  }, function (_, i) {\n    return hour12 ? i + 1 : i;\n  });\n  var listOfMinutes = Array.isArray(minutes) && minutes.length > 0 ? minutes : typeof minutes === 'function' ? Array.from({\n    length: 60\n  }, function (_, i) {\n    return i;\n  }).filter(function (minute) {\n    return minutes(minute);\n  }) : Array.from({\n    length: 60\n  }, function (_, i) {\n    return i;\n  });\n  var listOfSeconds = Array.isArray(seconds) && seconds.length > 0 ? seconds : typeof seconds === 'function' ? Array.from({\n    length: 60\n  }, function (_, i) {\n    return i;\n  }).filter(function (second) {\n    return seconds(second);\n  }) : Array.from({\n    length: 60\n  }, function (_, i) {\n    return i;\n  });\n  return {\n    listOfHours: formatTimePartials(listOfHours, locale, 'hour'),\n    listOfMinutes: formatTimePartials(listOfMinutes, locale, 'minute'),\n    listOfSeconds: formatTimePartials(listOfSeconds, locale, 'second'),\n    hour12: hour12\n  };\n};\n/**\n * Gets the selected hour from a date object in either 12-hour or 24-hour format based on locale and preference.\n * @param {Date | null} date The date object from which to extract the hour. If null, the function returns an empty string.\n * @param {string} locale The locale to use when determining whether to return in 12-hour or 24-hour format.\n * @param {'auto' | boolean} ampm Determines the format of the hour returned. 'auto' decides based on locale, true forces 12-hour format, and false forces 24-hour format.\n * @returns {string | number} The hour in the specified format or an empty string if the date is null.\n */\n\n\nvar getSelectedHour = function (date, locale, ampm) {\n  if (ampm === void 0) {\n    ampm = 'auto';\n  }\n\n  return date ? ampm === 'auto' && isAmPm(locale) || ampm === true ? convert24hTo12h(date.getHours()) : date.getHours() : '';\n};\n/**\n * Gets the selected minutes from a date object.\n * @param {Date | null} date The date object from which to extract the minutes. If null, the function returns an empty string.\n * @returns {string | number} The minutes from the date or an empty string if the date is null.\n */\n\n\nvar getSelectedMinutes = function (date) {\n  return date ? date.getMinutes() : '';\n};\n/**\n * Gets the selected seconds from a date object.\n * @param {Date | null} date The date object from which to extract the seconds. If null, the function returns an empty string.\n * @returns {string | number} The seconds from the date or an empty string if the date is null.\n */\n\n\nvar getSelectedSeconds = function (date) {\n  return date ? date.getSeconds() : '';\n};\n/**\n * Determines if the given locale uses AM/PM format.\n * @param {string} locale The locale to check.\n * @returns {boolean} True if the locale uses AM/PM format, otherwise false.\n */\n\n\nvar isAmPm = function (locale) {\n  return ['am', 'AM', 'pm', 'PM'].some(function (el) {\n    return new Date().toLocaleString(locale).includes(el);\n  });\n};\n/**\n * Validates if the given string represents a valid time.\n * @param {string} time The time string to validate.\n * @returns {boolean} True if the string is a valid time, otherwise false.\n */\n\n\nvar isValidTime = function (time) {\n  var d = new Date(\"1970-01-01T\".concat(time));\n  return d instanceof Date && !Number.isNaN(d.getTime());\n};\n/**\n * Checks whether the given locale formats the hour \"9\" with a leading zero (\"09\")\n * when using `hour: 'numeric'` in `toLocaleTimeString`.\n *\n * This helps determine if you should force `hour: '2-digit'` for consistent formatting.\n *\n * @param {string} locale - The locale code (e.g., \"en-US\", \"pl-PL\").\n * @returns {boolean} `true` if the formatted hour starts with a leading zero, otherwise `false`.\n */\n\n\nvar shouldUseTwoDigitHour = function (locale) {\n  var d = new Date(2020, 0, 1, 7, 5, 7); // 7:05:07\n\n  var formatted = d.toLocaleTimeString(locale);\n  return formatted.startsWith('0'); // check if the hour starts with \"0\"\n};\n\nexport { convert12hTo24h, convert24hTo12h, convertTimeToDate, formatTimePartials, getAmPm, getLocalizedTimePartials, getSelectedHour, getSelectedMinutes, getSelectedSeconds, isAmPm, isValidTime, shouldUseTwoDigitHour };","map":{"version":3,"mappings":"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","names":["abbr","hour","convert24hTo12h","convertTimeToDate","time","Date","concat","date","locale","toLocaleTimeString","includes","getHours","formatTimePartials","values","partial","forceTwoDigit","shouldUseTwoDigitHour","formatter","Intl","DateTimeFormat","minute","second","map","value","setHours","setMinutes","setSeconds","label","formatToParts","find","part","type","_a","getLocalizedTimePartials","ampm","hours","minutes","seconds","hour12","isAmPm","listOfHours","Array","isArray","length","from","_","i","filter","listOfMinutes","listOfSeconds","getSelectedHour","getSelectedMinutes","getMinutes","getSelectedSeconds","getSeconds","some","el","toLocaleString","isValidTime","d","Number","isNaN","getTime","formatted","startsWith"],"sources":["C:\\wamp64\\www\\Movie-react\\node_modules\\@coreui\\react-pro\\src\\components\\time-picker\\utils.ts"],"sourcesContent":["import type { AmPm, FormattedPartial, LocalizedTimePartials } from './types'\n\n/**\n * Converts a 12-hour time format to a 24-hour time format.\n * @param {('am' | 'pm')} abbr The abbreviation indicating AM or PM.\n * @param {number} hour The hour to be converted.\n * @returns {number} The hour in 24-hour format.\n */\nexport const convert12hTo24h = (abbr: AmPm, hour: number): number => {\n  if (abbr === 'am' && hour === 12) {\n    return 0\n  }\n\n  if (abbr === 'am') {\n    return hour\n  }\n\n  if (abbr === 'pm' && hour === 12) {\n    return 12\n  }\n\n  return hour + 12\n}\n\n/**\n * Converts a 24-hour time format to a 12-hour format.\n * @param {number} hour The hour to be converted.\n * @returns {number} The hour in 12-hour format.\n */\nexport const convert24hTo12h = (hour: number): number => hour % 12 || 12\n\n/**\n * Converts a time input into a Date object.\n * @param {Date | string | null | undefined} time The time input to be converted.\n * @returns {Date | null} The converted Date object or null if the input is falsy.\n */\nexport const convertTimeToDate = (time: Date | string | null | undefined): Date | null =>\n  time ? (time instanceof Date ? time : new Date(`1970-01-01 ${time}`)) : null\n\n/**\n * Retrieves the AM/PM part of the specified date according to the given locale.\n * @param {Date} date The date from which to extract the AM/PM part.\n * @param {string} locale The locale to use for formatting.\n * @returns {string} 'am' or 'pm' based on the given date and locale.\n */\nexport const getAmPm = (date: Date, locale: string): AmPm => {\n  if (date.toLocaleTimeString(locale).includes('AM')) {\n    return 'am'\n  }\n\n  if (date.toLocaleTimeString(locale).includes('PM')) {\n    return 'pm'\n  }\n\n  return date.getHours() >= 12 ? 'pm' : 'am'\n}\n\n/**\n * Formats an array of time values (hours, minutes, or seconds) according to the specified locale and partial.\n * @param {number[]} values An array of time values to format.\n * @param {string} locale The locale to use for formatting.\n * @param {('hour' | 'minute' | 'second')} partial The type of time value to format.\n * @returns {Array} An array of objects with the original value and its localized label.\n */\nexport const formatTimePartials = (\n  values: number[],\n  locale: string,\n  partial: 'hour' | 'minute' | 'second'\n): FormattedPartial[] => {\n  const date = new Date()\n  const forceTwoDigit = shouldUseTwoDigitHour(locale)\n  const formatter = new Intl.DateTimeFormat(locale, {\n    hour: forceTwoDigit ? '2-digit' : 'numeric',\n    minute: '2-digit',\n    second: '2-digit',\n  })\n\n  return values.map((value) => {\n    if (partial === 'hour') {\n      date.setHours(value)\n    }\n\n    if (partial === 'minute') {\n      date.setMinutes(value)\n    }\n\n    if (partial === 'second') {\n      date.setSeconds(value)\n    }\n\n    return {\n      value,\n      label: formatter.formatToParts(date).find((part) => part.type === partial)?.value || '',\n    }\n  })\n}\n\n/**\n * Generates localized time partials (hours, minutes, seconds) based on the given parameters.\n * @param {string} locale The locale to use for generating localized time partials.\n * @param {'auto' | boolean} ampm Determines whether to use 12-hour or 24-hour format. 'auto' decides based on locale.\n * @param {boolean | number[] | Function} hours An array of hours, a boolean, or a function to generate hours.\n * @param {boolean | number[] | Function} minutes An array of minutes, a boolean, or a function to generate minutes.\n * @param {boolean | number[] | Function} seconds An array of seconds, a boolean, or a function to generate seconds.\n * @returns {LocalizedTimePartials} An object containing arrays of localized time partials and a boolean indicating if 12-hour format is used.\n */\nexport const getLocalizedTimePartials = (\n  locale: string,\n  ampm: 'auto' | boolean = 'auto',\n  hours: boolean | number[] | ((hour: number) => number[]) = [],\n  minutes: boolean | number[] | ((minute: number) => number[]) = [],\n  seconds: boolean | number[] | ((second: number) => number[]) = []\n): LocalizedTimePartials => {\n  const hour12 = (ampm === 'auto' && isAmPm(locale)) || ampm === true\n\n  const listOfHours =\n    Array.isArray(hours) && hours.length > 0\n      ? hours\n      : typeof hours === 'function'\n        ? Array.from({ length: hour12 ? 12 : 24 }, (_, i) => (hour12 ? i + 1 : i)).filter((hour) =>\n            hours(hour)\n          )\n        : Array.from({ length: hour12 ? 12 : 24 }, (_, i) => (hour12 ? i + 1 : i))\n\n  const listOfMinutes =\n    Array.isArray(minutes) && minutes.length > 0\n      ? minutes\n      : typeof minutes === 'function'\n        ? Array.from({ length: 60 }, (_, i) => i).filter((minute) => minutes(minute))\n        : Array.from({ length: 60 }, (_, i) => i)\n\n  const listOfSeconds =\n    Array.isArray(seconds) && seconds.length > 0\n      ? seconds\n      : typeof seconds === 'function'\n        ? Array.from({ length: 60 }, (_, i) => i).filter((second) => seconds(second))\n        : Array.from({ length: 60 }, (_, i) => i)\n\n  return {\n    listOfHours: formatTimePartials(listOfHours, locale, 'hour'),\n    listOfMinutes: formatTimePartials(listOfMinutes, locale, 'minute'),\n    listOfSeconds: formatTimePartials(listOfSeconds, locale, 'second'),\n    hour12,\n  }\n}\n\n/**\n * Gets the selected hour from a date object in either 12-hour or 24-hour format based on locale and preference.\n * @param {Date | null} date The date object from which to extract the hour. If null, the function returns an empty string.\n * @param {string} locale The locale to use when determining whether to return in 12-hour or 24-hour format.\n * @param {'auto' | boolean} ampm Determines the format of the hour returned. 'auto' decides based on locale, true forces 12-hour format, and false forces 24-hour format.\n * @returns {string | number} The hour in the specified format or an empty string if the date is null.\n */\nexport const getSelectedHour = (\n  date: Date | null,\n  locale: string,\n  ampm: 'auto' | boolean = 'auto'\n): number | string =>\n  date\n    ? (ampm === 'auto' && isAmPm(locale)) || ampm === true\n      ? convert24hTo12h(date.getHours())\n      : date.getHours()\n    : ''\n\n/**\n * Gets the selected minutes from a date object.\n * @param {Date | null} date The date object from which to extract the minutes. If null, the function returns an empty string.\n * @returns {string | number} The minutes from the date or an empty string if the date is null.\n */\nexport const getSelectedMinutes = (date: Date | null): number | string =>\n  date ? date.getMinutes() : ''\n\n/**\n * Gets the selected seconds from a date object.\n * @param {Date | null} date The date object from which to extract the seconds. If null, the function returns an empty string.\n * @returns {string | number} The seconds from the date or an empty string if the date is null.\n */\nexport const getSelectedSeconds = (date: Date | null): number | string =>\n  date ? date.getSeconds() : ''\n\n/**\n * Determines if the given locale uses AM/PM format.\n * @param {string} locale The locale to check.\n * @returns {boolean} True if the locale uses AM/PM format, otherwise false.\n */\nexport const isAmPm = (locale: string): boolean =>\n  ['am', 'AM', 'pm', 'PM'].some((el) => new Date().toLocaleString(locale).includes(el))\n\n/**\n * Validates if the given string represents a valid time.\n * @param {string} time The time string to validate.\n * @returns {boolean} True if the string is a valid time, otherwise false.\n */\nexport const isValidTime = (time: string): boolean => {\n  const d = new Date(`1970-01-01T${time}`)\n  return d instanceof Date && !Number.isNaN(d.getTime())\n}\n\n/**\n * Checks whether the given locale formats the hour \"9\" with a leading zero (\"09\")\n * when using `hour: 'numeric'` in `toLocaleTimeString`.\n *\n * This helps determine if you should force `hour: '2-digit'` for consistent formatting.\n *\n * @param {string} locale - The locale code (e.g., \"en-US\", \"pl-PL\").\n * @returns {boolean} `true` if the formatted hour starts with a leading zero, otherwise `false`.\n */\nexport const shouldUseTwoDigitHour = (locale: string): boolean => {\n  const d = new Date(2020, 0, 1, 7, 5, 7) // 7:05:07\n  const formatted = d.toLocaleTimeString(locale)\n\n  return formatted.startsWith('0') // check if the hour starts with \"0\"\n}\n"]},"metadata":{},"sourceType":"module"}